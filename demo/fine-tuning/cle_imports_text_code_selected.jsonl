{"imports": "import pyclesperanto_prototype as cle\n\nfrom skimage.io import imread, imsave, imshow\nimport matplotlib\nimport numpy as np\n\n# initialize GPU\ncle.select_device(\"GTX\")", "text": "\n\n## Crop out a part of the image", "code": "width = 75\nheight = 75\ntile = cle.create([height, width])\n\nx = 10\ny = 10\ncle.crop(image, tile, x, y)\n\ntile"}
{"imports": "import pyclesperanto_prototype as cle\n\nfrom skimage.io import imread, imsave, imshow\nimport matplotlib\nimport numpy as np\n\n# initialize GPU\ncle.select_device(\"GTX\")", "text": "\n\n## Create output image\nWe create an empty image and make a collage by pasting the cropped image into it. We also transform the cropped image for visualisation purpose:", "code": "collage = cle.create([width * 2 + 6, height * 2 + 6])\n\n# \"white\" background\ncle.set(collage, 255)\n\ncollage"}
{"imports": "import numpy as np\nimport cupy as cp\nimport cupyx.scipy.ndimage as ndi\nimport pyclesperanto_prototype as cle\nfrom skimage.io import imread", "text": "\n\nJust as an example, we can now threshold the image using `threshold_otsu` which is provided by clesperanto but not by cupy.", "code": "cl_binary = cle.threshold_otsu(cp_filtered)\ncl_binary.shape"}
{"imports": "import numpy as np\nimport cupy as cp\nimport cupyx.scipy.ndimage as ndi\nimport pyclesperanto_prototype as cle\nfrom skimage.io import imread", "text": "\n\nA cupy-image can also be visualized using clesperantos imshow:", "code": "cle.imshow(cu_edges)"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\n\ncle.available_device_names()", "text": "\n\nYou can then select a GPU and process on it.", "code": "cle.select_device('gfx')\n\nimage = np.random.random((10, 100, 100))\nprocessed_image = cle.gaussian_blur(image, sigma_x=10)\ncle.imshow(processed_image)"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle  # version 0.19.3", "text": "\n\n## top hat box", "code": "image1_thb = cle.top_hat_box(image0_L0r, None, 10.0, 10.0, 0.0)\nimage1_thb"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"RTX\")\n\nblobs = cle.asarray(imread(\"../../data/blobs.tif\"))\nblobs", "text": "\n\n## Local Variance filter", "code": "blobs_edges = cle.variance_box(blobs, radius_x=5, radius_y=5)\nblobs_edges"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"RTX\")\n\nblobs = cle.asarray(imread(\"../../data/blobs.tif\"))\nblobs", "text": "\n\n# Local standard deviation\n... is just the square root of the local variance", "code": "blobs_edges = cle.standard_deviation_box(blobs, radius_x=5, radius_y=5)\nblobs_edges"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"RTX\")\n\nblobs = cle.asarray(imread(\"../../data/blobs.tif\"))\nblobs", "text": "\n\n## Edge detection is not edge enhancement\nIntuitively, one could apply an edge detection filter to enhance edges in images showing edges. Let's try with an image showing membranes. It's a 3D image btw.", "code": "image = cle.asarray(imread(\"../../data/EM_C_6_c0.tif\"))\nimage\n\nimage[60]\n\nimage_sobel = cle.sobel(image)\nimage_sobel[60]"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"RTX\")\n\nblobs = cle.asarray(imread(\"../../data/blobs.tif\"))\nblobs", "text": "\n\n## Enhancing edges\nThus, to enhance edges in a membrane image, other filters are more useful. Enhancement may for example mean making membranes thicker and potentially closing gaps.\n\n## Local standard deviation", "code": "image_std = cle.standard_deviation_box(image, radius_x=5, radius_y=5, radius_z=5)\nimage_std[60]"}
{"imports": "from dask import array\ndask_array = array.random.random((450, 1024,1024))\ndask_array", "text": "\n\nPerform Gaussian blur with dask_array on GPU", "code": "blurred_device = cle.gaussian_blur(dask_array)\nblurred_device"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle", "text": "\n\n## Customization with `imshow`\nFor customized visualization of the image, e.g. colormaps and colorbars, use `imshow()`.", "code": "cle.imshow(cle_blobs, colormap='jet', colorbar=True)"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle", "text": "\n\n## Label images\nThe visualization interprets `uint32` pixel type as label image and visualizes label images in color.", "code": "labels = cle.voronoi_otsu_labeling(blobs, spot_sigma=3.5)\n\nlabels"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle", "text": "\n\nYou can visualize indiviual slices like when slicing numpy-arrays.", "code": "head[60]\n\nhead[:, 100]\n\nhead[:,:,100]"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\n\ncle.get_device()", "text": "\n\n## Determining the presign of pixels", "code": "data = np.asarray([[-np.inf],\n                    [np.inf],\n                    [np.nan],\n                    [0],\n                    [1],\n                    [-1]])\n\nnp.sign(data)\n\ncle.sign(data)"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\n\ncle.get_device()", "text": "\n\n## Absolute", "code": "data = [[-3, 4]]\n\nnp.fabs(data)\n\ncle.fabs(data)"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\n\ncle.get_device()", "text": "\n\n## Square", "code": "np.square(data)\n\ncle.power(data, exponent=2)"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\n\ncle.get_device()", "text": "\n\n## Cubic root", "code": "data = [[27, 8]]\n\nnp.cbrt(data)\n\ncle.cbrt(data)"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\n\ncle.get_device()", "text": "\n\n## Clip", "code": "data = [[1,2], [3,4]]\n\nnp.clip(data, a_min=2, a_max=3)\n\ncle.clip(data, a_min=2, a_max=3)"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\n\ncle.get_device()", "text": "\n\n## Modulo", "code": "test = [[4, 5]]\ntest_div = [[2, 2]]\n\nnp.mod(test, test_div)\n\ncle.mod(test, test_div)"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nfrom skimage.io import imread, imshow\nimport matplotlib.pyplot as plt\n\ncle.get_device()", "text": "\n\nThe `count_map` is a parametric image. We can identify all the nuclei where the count value >= 1. These are all the Cy3-positive nuclei which have at least one eGFP-positive nucleus with a centroid distance <= 15 pixels. ", "code": "double_positive_nuclei = cle.exclude_labels_with_map_values_out_of_range(\n    count_map, \n    nuclei_cy3, \n    minimum_value_range=1)\n\ncle.imshow(double_positive_nuclei, labels=True)"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nfrom skimage.io import imread, imshow\nimport matplotlib.pyplot as plt\n\ncle.get_device()", "text": "\n\n## Visualization\nWe can also use the outlines around cells which are double positive and visualize those on the original images of both channels.", "code": "# determine outlines\noutlines = cle.detect_label_edges(double_positive_nuclei)\n\n# add outlines to original images. As outlines have value 1, \n# we need to multiply them to make them properly visible:\nchannel_0_with_outlines = cle.maximum_images(channel_0, outlines * channel_0.max())\n\n# visualize result\ncle.imshow(channel_0_with_outlines)\n\n# let's zoom in\ncle.imshow(channel_0_with_outlines.get()[400:800, 1000:1700])"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nfrom skimage.io import imread, imshow\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ncle.get_device()", "text": "\n\nFirstly, we can measure the intensity in the second channel, marked with eGFP and visualize that measurement in a parametric image. In such a parametric image, all pixels inside a nucleus have the same value, in this case the mean average intensity of the cell.", "code": "intensity_map = cle.mean_intensity_map(channel_egfp, nuclei_cy3)\n\n# visualize\nfig, axs = plt.subplots(1, 2, figsize=(15,15))\ncle.imshow(channel_egfp, plot=axs[0], color_map=\"gray\")\ncle.imshow(intensity_map, plot=axs[1], color_map=\"gray\")"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nfrom skimage.io import imread, imshow\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ncle.get_device()", "text": "\n\nThe intensity vector can then be retrieved from the tabular statistics. Note: In this case, the background intensity is not 0, because we were directly reading it from the original image.", "code": "intensity_vector2 = statistics['mean_intensity']\nintensity_vector2"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.data import cells3d\nimport numpy as np", "text": "\n\nFirst we visualize these lines on top of the membrane image.", "code": "mesh = cle.create_like(membranes)\nmesh = cle.touch_matrix_to_mesh(coords, connection_matrix, mesh)\n\ncle.imshow(membranes, continue_drawing=True)\ncle.imshow(mesh, alpha=0.5, colormap='jet')"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.data import cells3d\nimport numpy as np", "text": "\n\n## Measure the mean intensity along lines\nNext we use the matrix configured above to measure the mean average intensity along the lines. We also need to specify how many samples will be taken along the lines.", "code": "num_samples = 10\n\nmean_intensity_matrix = cle.generate_mean_intensity_between_points_matrix(\n                                membranes, coords, connection_matrix, num_samples=num_samples)\nmean_intensity_matrix"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.data import cells3d\nimport numpy as np", "text": "\n\nWe can visualize these measurements also again as lines. As we pass points and connections between points as matrix, this is technically a mesh.", "code": "mean_intensity_mesh = cle.create_like(membranes)\nmean_intensity_mesh = cle.touch_matrix_to_mesh(coords, mean_intensity_matrix, mean_intensity_mesh)\nmean_intensity_mesh"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport pandas as pd\nimport numpy as np\nimport stackview", "text": "\n\nWe select an NVidida (GTX or RTX) GPU if available.", "code": "cle.select_device('TX')"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport pandas as pd\nimport numpy as np\nimport stackview", "text": "\n\n## Neighborhood definitions\nWe differentiate three kinds of neighborhoods. \n\n### Touching neighbors\nTo demonstrate touching neighborhoods, we increase the size of our labeled objects a bit first.", "code": "larger_labels = cle.dilate_labels(labels, radius=6)\nlarger_labels"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport pandas as pd\nimport numpy as np\nimport stackview", "text": "\n\n## We can then connect the centroids of touching objects.", "code": "touching_mesh = cle.draw_mesh_between_touching_labels(larger_labels)\ntouching_mesh"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport pandas as pd\nimport numpy as np\nimport stackview", "text": "\n\nclesperanto's `imshow` function allows to overlay both images.", "code": "cle.imshow(larger_labels, labels=True, continue_drawing=True)\ncle.imshow(touching_mesh, alpha=0.5)"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport pandas as pd\nimport numpy as np\nimport stackview", "text": "\n\n### n-nearest neighbors\n\nAlso the n-nearest neighbors are drived from the distances between centroids. When interpreting the resulting neighbor-mesh, it is possible that a n=2-neighbor mesh contains objects that have connections to more than 2 neighbors. The unterlying reason is that the other object might connect to them.", "code": "n = 2\n\nn_nearest_neighbors_mesh = cle.draw_mesh_between_n_closest_labels(labels, n=n)\n\ncle.imshow(labels, labels=True, continue_drawing=True)\ncle.imshow(n_nearest_neighbors_mesh, alpha=0.5)"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport pandas as pd\nimport numpy as np\nimport stackview", "text": "\n\nNote that this neighborhoood-representation is centroid-based. Collaborators have asked for distances between edges of objects. This is hard to compute on graphics cards, because it is tricky to paralellize.\n\n### Proximal neighbors\nProximal neighbors are neighbors which have a centroid distance below a given threshold", "code": "distance_threshold = 30\n\nproximal_neighbors_mesh1 = cle.draw_mesh_between_proximal_labels(labels, maximum_distance=distance_threshold)\n\ncle.imshow(labels, labels=True, continue_drawing=True)\ncle.imshow(proximal_neighbors_mesh1, alpha=0.5)\n\ndistance_threshold = 60\n\nproximal_neighbors_mesh2 = cle.draw_mesh_between_proximal_labels(labels, maximum_distance=distance_threshold)\n\ncle.imshow(labels, labels=True, continue_drawing=True)\ncle.imshow(proximal_neighbors_mesh2, alpha=0.5)"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport pandas as pd\nimport numpy as np\nimport stackview", "text": "\n\n## Basic neighborhood quantification\nThe meshes shown above are quite informative visually. If one wanted to quantify these visual representations, one could for example count the number of neighbors within a given radius.", "code": "proximal_neighbor_count_map = cle.proximal_neighbor_count_map(labels, max_distance=distance_threshold)\n\ncle.imshow(proximal_neighbor_count_map, colorbar=True, colormap='jet')"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport pandas as pd\nimport numpy as np\nimport stackview", "text": "\n\n## Quantitative meshes\nThere are also visual forms of representing measurements on neighborhood graphs.\n\n### Distance meshes\nIn this distance meshes the value/'color' along the mesh lines represents a quantiative measurement.", "code": "distance_mesh = cle.draw_distance_mesh_between_proximal_labels(labels, maximum_distance=distance_threshold)\n\ncle.imshow(labels > 0, continue_drawing=True)\ncle.imshow(distance_mesh, alpha=0.7, min_display_intensity=30, max_display_intensity=distance_threshold, colormap='jet', colorbar=True)"}
{"imports": "import pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport pandas as pd\nimport numpy as np\nimport stackview", "text": "\n\n## Merging touching labels\nThere are also short-cuts to similar functions such as for merging touching labels.", "code": "labels\n\ncle.merge_touching_labels(labels)"}
{"imports": "import pyclesperanto_prototype as cle\nimport igraph\nimport networkx\nfrom skimage.io import imread, imsave, imshow\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"amd\")", "text": "\n\n... and visualizing a graph of proximal objects which have a maximum centroid distance of 50 pixels.", "code": "mesh = cle.draw_mesh_between_proximal_labels(labels, maximum_distance=50)\ncle.imshow(mesh)"}
{"imports": "import pyclesperanto_prototype as cle\nimport igraph\nimport networkx\nfrom skimage.io import imread, imsave, imshow\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"amd\")", "text": "\n\n## igraph\nWe can also retrieve an analogous igraph graph directly from the label image", "code": "igraph_graph = cle.proximal_labels_to_igraph(labels, maximum_distance=50)\n\nfig, ax = plt.subplots()\nigraph.plot(igraph_graph, target=ax)"}
{"imports": "import pyclesperanto_prototype as cle\nimport igraph\nimport networkx\nfrom skimage.io import imread, imsave, imshow\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"amd\")", "text": "\n\nNote: The visualization is flipped because the origin of the coordinate system is on the bottom left, while in clesperanto it's on the top left, because clesperanto uses community standards from the image processing field.\n\n## networkx\nThe same also works with networkx.", "code": "networkx_graph = cle.proximal_labels_to_networkx(labels, maximum_distance=50)\n\npos = networkx.get_node_attributes(networkx_graph,'pos')\n\nnetworkx.draw(networkx_graph, pos)"}
{"imports": "import pyclesperanto_prototype as cle\nimport igraph\nimport networkx\nfrom skimage.io import imread, imsave, imshow\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"amd\")", "text": "\n\n## n-nearest neighbors\nWe can alternatively also create networks between n-nearest neighbors for all", "code": "igraph_graph = cle.n_nearest_labels_to_igraph(labels, n=3)\n\nfig, ax = plt.subplots()\nigraph.plot(igraph_graph, target=ax)\n\nnetworkx_graph = cle.n_nearest_labels_to_networkx(labels, n=3)\n\npos = networkx.get_node_attributes(networkx_graph,'pos')\n\nnetworkx.draw(networkx_graph, pos)"}
{"imports": "import pyclesperanto_prototype as cle\nimport igraph\nimport networkx\nfrom skimage.io import imread, imsave, imshow\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"amd\")", "text": "\n\n## touching neighbors\nStarting from a label image where neighbors touch, we can also generate graphs between those.", "code": "touching_labels = cle.dilate_labels(labels, radius=5)\n\ncle.imshow(touching_labels, labels=True)\n\nigraph_graph = cle.touching_labels_to_igraph(touching_labels)\n\nfig, ax = plt.subplots()\nigraph.plot(igraph_graph, target=ax)\n\nnetworkx_graph = cle.touching_labels_to_networkx(touching_labels)\n\npos = networkx.get_node_attributes(networkx_graph,'pos')\n\nnetworkx.draw(networkx_graph, pos)"}
{"imports": "import pyclesperanto_prototype as cle\nimport igraph\nimport networkx\nfrom skimage.io import imread, imsave, imshow\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncle.select_device(\"amd\")", "text": "\n\nAs you can see, the igraph is directed. To make it direct in both direction along all edges, you can convert the adjacency matrix before passing it to `to_igraph`:", "code": "bidirectional_matrix = cle.touch_matrix_to_adjacency_matrix(adjacency_matrix)\ncle.set_where_x_equals_y(bidirectional_matrix, 0)\n\nigraph_graph = cle.to_igraph(bidirectional_matrix, centroids)\nfig, ax = plt.subplots()\nigraph.plot(igraph_graph, target=ax)"}
{"imports": "import apoc\nfrom skimage.io import imread, imshow, imsave\nimport pyclesperanto_prototype as cle\nimport numpy as np\nimport stackview", "text": "\n\nWe can now merge all cells whose borders are annotated.", "code": "result = cle.merge_annotated_touching_labels(oversegmented, annotation)\nresult"}
{"imports": "import pyclesperanto_prototype as cle\nfrom numpy import random\nfrom skimage.io import imshow", "text": "\n\n# Sepcial meshes\n## Mesh of touching neighbors", "code": "angle_mesh = cle.touch_matrix_to_mesh(centroids, touch_matrix)\ncle.imshow(angle_mesh)"}
{"imports": "import pyclesperanto_prototype as cle\nfrom numpy import random\nfrom skimage.io import imshow", "text": "\n\n## Mesh nearest neighbors", "code": "nearest_neighbor_mesh = cle.draw_mesh_between_n_closest_labels(cells, n=1)\ncle.imshow(nearest_neighbor_mesh)"}
{"imports": "import pyclesperanto_prototype as cle\nfrom numpy import random\nfrom skimage.io import imshow", "text": "\n\n## Meshes of proximal neighbors/", "code": "close_neighbors_mesh = cle.draw_mesh_between_proximal_labels(cells, maximum_distance=25)\ncle.imshow(close_neighbors_mesh)"}
{"imports": "import pyclesperanto_prototype as cle\nfrom numpy import random\nfrom skimage.io import imshow", "text": "\n\n## Distance meshes\nThis is the same custom mesh as shown in the section on top", "code": "distance_mesh = cle.draw_distance_mesh_between_touching_labels(cells)\ncle.imshow(distance_mesh)"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nimport matplotlib\nfrom numpy.random import random\n\ncle.select_device(\"RTX\")\n\n# Generate artificial cells as test data\ntissue = cle.artificial_tissue_2d()\n\n# fill it with random measurements\nvalues = random([int(cle.maximum_of_all_pixels(tissue))])\nfor i, y in enumerate(values):\n    if (i != 95):\n        values[i] = values[i] * 10 + 45\n    else:\n        values[i] = values[i] * 10 + 90\n\nmeasurements = cle.push(np.asarray([values]))\n\n# visualize measurments in space\nexample_image = cle.replace_intensities(tissue, measurements)", "text": "\n\n## Touching neighbors\nWe can show all cells that belong to the \"touch\" neighborhood by computing the local maximum intensity in this neighborhood. Let's visualize the touching neighbor graph as mesh first.", "code": "mesh = cle.draw_mesh_between_touching_labels(tissue)\n\n# make lines a bit thicker for visualization purposes\nmesh = cle.maximum_sphere(mesh, radius_x=1, radius_y=1)\n\ncle.imshow(mesh)"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nimport matplotlib\nfrom numpy.random import random\n\ncle.select_device(\"RTX\")\n\n# Generate artificial cells as test data\ntissue = cle.artificial_tissue_2d()\n\n# fill it with random measurements\nvalues = random([int(cle.maximum_of_all_pixels(tissue))])\nfor i, y in enumerate(values):\n    if (i != 95):\n        values[i] = values[i] * 10 + 45\n    else:\n        values[i] = values[i] * 10 + 90\n\nmeasurements = cle.push(np.asarray([values]))\n\n# visualize measurments in space\nexample_image = cle.replace_intensities(tissue, measurements)", "text": "\n\nFrom those neighbor-graph one can compute local properties, for example the maximum:", "code": "local_maximum = cle.maximum_of_touching_neighbors_map(example_image, tissue)\n\ncle.imshow(local_maximum, min_display_intensity=30, max_display_intensity=90, color_map='jet')"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nimport matplotlib\nfrom numpy.random import random\n\ncle.select_device(\"RTX\")\n\n# Generate artificial cells as test data\ntissue = cle.artificial_tissue_2d()\n\n# fill it with random measurements\nvalues = random([int(cle.maximum_of_all_pixels(tissue))])\nfor i, y in enumerate(values):\n    if (i != 95):\n        values[i] = values[i] * 10 + 45\n    else:\n        values[i] = values[i] * 10 + 90\n\nmeasurements = cle.push(np.asarray([values]))\n\n# visualize measurments in space\nexample_image = cle.replace_intensities(tissue, measurements)", "text": "\n\n## Neighbors of touching neighbors\nYou can also extend the neighborhood by considering neighbors of neighbor (of neighbors (of neighbors)). How far you go, can be configured with a radius parameter. Note: Radiu==0 means, no neighbors are taken into account, radius==1 is identical with touching neighbors, radius > 1 are neighbors of neighbors:", "code": "for radius in range(0, 5):\n    local_maximum = cle.maximum_of_touching_neighbors_map(example_image, tissue, radius=radius)\n    cle.imshow(local_maximum, min_display_intensity=30, max_display_intensity=90, color_map='jet')"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nimport matplotlib\nfrom numpy.random import random\n\ncle.select_device(\"RTX\")\n\n# Generate artificial cells as test data\ntissue = cle.artificial_tissue_2d()\ntouch_matrix = cle.generate_touch_matrix(tissue)\n\ncle.imshow(tissue, labels=True)", "text": "\n\n# Local averaging smoothes edges\nBy averaging measurments locally, we can reduce the noise, but we also introduce a stripe where the region touch", "code": "local_mean_measurements = cle.mean_of_touching_neighbors(measurements, touch_matrix)\n\nparametric_image = cle.replace_intensities(tissue, local_mean_measurements)\ncle.imshow(parametric_image, min_display_intensity=0, max_display_intensity=100, color_map='jet')"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nimport matplotlib\nfrom numpy.random import random\n\ncle.select_device(\"RTX\")\n\n# Generate artificial cells as test data\ntissue = cle.artificial_tissue_2d()\ntouch_matrix = cle.generate_touch_matrix(tissue)\n\ncle.imshow(tissue, labels=True)", "text": "\n\n# Edge preserving filters: median\nBy averaging using a median filter, we can also reduce noise while keeping the edge between the regions sharp", "code": "local_median_measurements = cle.median_of_touching_neighbors(measurements, touch_matrix)\n\nparametric_image = cle.replace_intensities(tissue, local_median_measurements)\ncle.imshow(parametric_image, min_display_intensity=0, max_display_intensity=100, color_map='jet')"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nimport matplotlib\nfrom numpy.random import random\n\ncle.select_device(\"RTX\")\n\n# Generate artificial cells as test data\ntissue = cle.artificial_tissue_2d()\ntouch_matrix = cle.generate_touch_matrix(tissue)\n\ncle.imshow(tissue, labels=True)", "text": "\n\n# Increasing filter radius: neighbors of neighbors\nIn order to increase the radius of the operation, we need to determin neighbors of touching neighbors", "code": "neighbor_matrix = cle.neighbors_of_neighbors(touch_matrix)\n\nlocal_median_measurements = cle.median_of_touching_neighbors(measurements, neighbor_matrix)\n\nparametric_image = cle.replace_intensities(tissue, local_median_measurements)\ncle.imshow(parametric_image, min_display_intensity=0, max_display_intensity=100, color_map='jet')"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport matplotlib.pyplot as plt\nimport pandas as pd", "text": "\n\n# Distance meshes\nBefore diving into details we should first have a look at neighborhood relationships and distances between neighbors. A distance mesh visualizes the distances between centroids in colour.", "code": "distance_mesh = cle.draw_distance_mesh_between_touching_labels(labels)\ncle.imshow(distance_mesh, colorbar=True, colormap=\"rainbow\")"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\nfrom skimage.io import imread\nimport matplotlib.pyplot as plt\nimport pandas as pd", "text": "\n\n## Visualization of statistics\nWe can visualize those measurements in parametric map images.\n\nFor visualization of the table columns as maps, we typically need to prefix the measurements with a `0`. This `0` represents the measurement of the background.", "code": "stats[\"touching_neighbor_count\"].tolist()\n\nlist_of_measurements = cle.prefix_in_x([stats[\"touching_neighbor_count\"].tolist()])\nlist_of_measurements\n\ncle.replace_intensities(labels, list_of_measurements)"}
{"imports": "import numpy as np\nfrom skimage.io import imshow\n\nrandom_image = np.random.random([512,512])\nbinary_image = random_image > 0.9995\n\n# push to GPU\ninput_image = cle.push(binary_image * random_image)\n\n# blur the image\nsigma = 3\nstarting_point = cle.gaussian_blur(input_image, sigma_x=sigma, sigma_y=sigma)\n\n# show input image\nstarting_point", "text": "\n\n## Local maxima detection", "code": "maxima = cle.detect_maxima_box(starting_point)\nmaxima"}
{"imports": "import numpy as np\nfrom skimage.io import imshow\n\nrandom_image = np.random.random([512,512])\nbinary_image = random_image > 0.9995\n\n# push to GPU\ninput_image = cle.push(binary_image * random_image)\n\n# blur the image\nsigma = 3\nstarting_point = cle.gaussian_blur(input_image, sigma_x=sigma, sigma_y=sigma)\n\n# show input image\nstarting_point", "text": "\n\n## Make a local threshold image", "code": "# Extend labeled maxima until they touch\nvoronoi_label_image = cle.extend_labeling_via_voronoi(labeled_maxima)\nvoronoi_label_image\n\n# Replace labels with thresholds\nthreshold_image = cle.replace_intensities(voronoi_label_image, thresholds)\nthreshold_image\n\n# Apply threshold\nbinary_segmented = cle.greater(starting_point, threshold_image)\nbinary_segmented"}
{"imports": "import pyclesperanto_prototype as cle\n\n# select a specific OpenCL / GPU device and see which one was chosen\ncle.select_device('RTX')", "text": "\n\nFor visualisation purposes we crop out a sub-region:", "code": "input_crop = cle.crop(input_image, start_x=bb_x, start_y=bb_y, width=bb_width, height=bb_height)\n\nfig, axs = plt.subplots(1, 2, figsize=(15, 15))\ncle.imshow(input_image, plot=axs[0])\ncle.imshow(input_crop, plot=axs[1])"}
{"imports": "import pyclesperanto_prototype as cle\n\n# select a specific OpenCL / GPU device and see which one was chosen\ncle.select_device('RTX')", "text": "\n\n## Applying the algorithm\nGauss-Otsu-labeling is a command in clesperanto, which asks for a sigma parameter. It controls how precise segmented objects are outlined (`outline_sigma`).", "code": "sigma_outline = 1\n\nsegmented = cle.gauss_otsu_labeling(input_image, outline_sigma=sigma_outline)\nsegmented_crop = cle.crop(segmented, start_x=bb_x, start_y=bb_y, width=bb_width, height=bb_height)\n\nfig, axs = plt.subplots(1, 2, figsize=(15, 15))\ncle.imshow(segmented, labels=True, plot=axs[0])\ncle.imshow(segmented_crop, labels=True, plot=axs[1])"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Gauss-Otsu-Labeling\nWe often use image blurring, e.g. using a [Gaussian blur](), [Otus's thresholding method]() and CCL in combination. Thus, pyclesperanto has a function which combines these operations and make them easier accessible. The parameter `outline_sigma` allows tuning the smoothness of the outline of the labeled objects. When increasing it, also small objects may disappear.", "code": "gol1 = cle.gauss_otsu_labeling(raw_image, outline_sigma=1)\ngol1\n\ngol5 = cle.gauss_otsu_labeling(raw_image, outline_sigma=5)\ngol5"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Voronoi-Otsu-Labeling\nAnother common approach is blurring the raw image, detecting maxima and using a binary watershed to flood a corresponding binary image with label values. Results are supposed to be similar to a binary image that has been processed by ImageJ's binary Watershed algorithm before it is passed to CCL. The algorithm has a parameter `outline_sigma` as explained above. Furthermore, the `spot_sigma` parameter allows to tune how distant local maxima are in the initial detection step.", "code": "vol1 = cle.voronoi_otsu_labeling(raw_image, outline_sigma=1, spot_sigma=1)\nvol1\n\nvol32 = cle.voronoi_otsu_labeling(raw_image, outline_sigma=1, spot_sigma=3.2)\nvol32"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n## Post-processing label images\n### Voronoi tesselation\nStarting at different label or binary images, we can partionion an entire image into labels using Voronoi tesselation.", "code": "tesselated_image = cle.extend_labeling_via_voronoi(vol32)\ntesselated_image"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\nSimilarly, starting from a binary image, we can label the objects using connected component labeling and then partion the image.", "code": "partioned_image = cle.voronoi_labeling(binary_image)\npartioned_image"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Exclude small/large labels\nYou can exclude small and large labels using dedicated operations. It is also possible to select a size range of labels to keep or remove.", "code": "large_labels = cle.exclude_small_labels(ccl_image_diamond, maximum_size=350)\nlarge_labels\n\nsmall_labels = cle.exclude_large_labels(ccl_image_diamond, minimum_size=200)\nsmall_labels\n\nmedium_sized_labels = cle.exclude_labels_out_of_size_range(ccl_image_diamond, minimum_size=200, maximum_size=350)\nmedium_sized_labels"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Combine label images\nYou can also combine label images.", "code": "combined_labels = cle.combine_labels(small_labels, large_labels)\ncombined_labels"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Dilating label images\nDilating label images, is similar to a maximum filter. The only difference is that labels don't overwrite each other.", "code": "dilated_labels_3 = cle.dilate_labels(combined_labels, radius=3)\ndilated_labels_3\n\ndilated_labels_7 = cle.dilate_labels(combined_labels, radius=7)\ndilated_labels_7"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Eroding label images\nWhen eroding label images, basically two options exist: Erode labels using a minimum-filter after introducing a background-pixel between labels, and eroding the labels while keeping their connected regions connected.", "code": "eroded_labels_3 = cle.erode_labels(dilated_labels_7, radius=3)\neroded_labels_3\n\neroded_connected_labels_3 = cle.erode_connected_labels(dilated_labels_7, radius=3)\neroded_connected_labels_3"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Label opening\nIn a similar way, labels can also be opened. Note: Depending on the radius, small labels may disappear.\n\nopened_labels_1 = cle.opening_labels(combined_labels, radius=1)\n\ncle.imshow(opened_labels_1, labels=True)", "code": "opened_labels_5 = cle.opening_labels(combined_labels, radius=5)\nopened_labels_5"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Label closing\nAnalogously, an operation for closing label images exists.", "code": "closed_labels_1 = cle.closing_labels(combined_labels, radius=1)\nclosed_labels_1\n\nclosed_labels_5 = cle.closing_labels(combined_labels, radius=5)\nclosed_labels_5"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Excluding labels according to other parameters\nWe can also exclude labels in a label image according to other parameters, e.g. using shape. Therefore, we need a parametric image where the pixels in the label correspond to the parameter we want to consider for excluding labels.", "code": "shape_parametric_image = cle.extension_ratio_map(closed_labels_1)\nshape_parametric_image\n\nminimum_extension_ratio = 1.8\nmaximum_extension_ratio = 100\nelongated_labels = cle.exclude_labels_with_map_values_out_of_range(\n    shape_parametric_image, \n    closed_labels_1, \n    minimum_value_range=minimum_extension_ratio,\n    maximum_value_range=maximum_extension_ratio,\n)\nelongated_labels"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n## Other operations\n### Label borders\nLabel border images can be derived as label image and as binary image.", "code": "label_border_image = cle.reduce_labels_to_label_edges(elongated_labels)\nlabel_border_image\n\nbinary_border_image = cle.detect_label_edges(elongated_labels)\nbinary_border_image"}
{"imports": "from skimage.io import imread\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n### Label centroids\nLabels can also be reduced to their centroids.", "code": "label_centroids_image = cle.reduce_labels_to_centroids(elongated_labels)\nlabel_centroids_image"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\nimport stackview", "text": "\n\nUsing the functions `mode_sphere` and `mode_box` we can make the result less noisy.", "code": "cle.mode_sphere(semantic_segmentation, radius_x=2, radius_y=2).astype(np.uint32)\n\ncle.mode_sphere(semantic_segmentation, radius_x=4, radius_y=4).astype(np.uint32)"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\nimport stackview", "text": "\n\nWhen the radius becomes wider and wider, the result contains less and less local information.", "code": "cle.mode_sphere(semantic_segmentation, radius_x=10, radius_y=10).astype(np.uint32)"}
{"imports": "from skimage.data import cells3d\nimport pyclesperanto_prototype as cle\n\nimage = cells3d()\nimage.shape\n\nnuclei = image[30, 1]\n\ncle.imshow(nuclei)\n\nlabels = cle.eroded_otsu_labeling(nuclei, number_of_erosions=11, outline_sigma=4)\n\ncle.imshow(labels, labels=True)", "text": "\n\n## Similar algorithm: Voronoi-Otsu-Labeling\nVoronoi-Otsu-Labeling is a similar algorithm. When you see labels swapping over in neighbor-objects when using it like shown below, you may want to give object-splitting-Otsu-labeling a try.", "code": "labels = cle.voronoi_otsu_labeling(nuclei, spot_sigma=10, outline_sigma=5)\n\ncle.imshow(labels, labels=True)"}
{"imports": "import pyclesperanto_prototype as cle\n\n# select a specific OpenCL / GPU device and see which one was chosen\ncle.select_device('RTX')", "text": "\n\nFurthermore, background intensity appears to increase, potentially a result if more scattering deep in the sample. We can compensate for that by using a background subtraction technique:", "code": "backgrund_subtracted = cle.top_hat_box(equalized_intensities_stack, radius_x=5, radius_y=5, radius_z=5)\nshow(backgrund_subtracted)"}
{"imports": "import pyclesperanto_prototype as cle\n\n# select a specific OpenCL / GPU device and see which one was chosen\ncle.select_device('RTX')", "text": "\n\n## Segmentation\n", "code": "segmented = cle.voronoi_otsu_labeling(backgrund_subtracted, spot_sigma=3, outline_sigma=1)\nshow(segmented, labels=True)"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle\nimport matplotlib.pyplot as plt", "text": "\n\nThe `smooth_labels` function allows to straighten the outlines of the labels.", "code": "cle.smooth_labels(labels, radius=5)"}
{"imports": "import pyclesperanto_prototype as cle\n\n# select a specific OpenCL / GPU device and see which one was chosen\ncle.select_device('RTX')", "text": "\n\n## Applying the algorithm\nVoronoi-Otsu-labeling is a command in clesperanto, which asks for two sigma parameters. The first sigma controls how close detected cells can be (`spot_sigma`) and second controls how precise segmented objects are outlined (`outline_sigma`).", "code": "sigma_spot_detection = 5\nsigma_outline = 1\n\nsegmented = cle.voronoi_otsu_labeling(input_gpu, spot_sigma=sigma_spot_detection, outline_sigma=sigma_outline)\nsegmented_crop = cle.crop(segmented, start_x=bb_x, start_y=bb_y, width=bb_width, height=bb_height)\n\nfig, axs = plt.subplots(1, 2, figsize=(15, 15))\ncle.imshow(segmented, labels=True, plot=axs[0])\ncle.imshow(segmented_crop, labels=True, plot=axs[1])"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nfrom skimage.io import imshow\nimport matplotlib\n\n# Generate artificial cells as test data\ntissue = cle.artificial_tissue_2d()\n\ncle.imshow(tissue, labels=True)\n\nmembranes = cle.detect_label_edges(tissue)\ncle.imshow(membranes)", "text": "\n\n# Analysis and visualization of neighbor count", "code": "touch_matrix = cle.generate_touch_matrix(tissue)\nneighbor_count = cle.count_touching_neighbors(touch_matrix)\n\nparametric_image = cle.replace_intensities(tissue, neighbor_count)\ncle.imshow(parametric_image, min_display_intensity=0, max_display_intensity=10, color_map='jet')\n"}
{"imports": "import pyclesperanto_prototype as cle\nimport numpy as np\nfrom skimage.io import imshow\nimport matplotlib\n\n# Generate artificial cells as test data\ntissue = cle.artificial_tissue_2d()\n\ncle.imshow(tissue, labels=True)\n\nmembranes = cle.detect_label_edges(tissue)\ncle.imshow(membranes)", "text": "\n\n## Average the measurement between cells to reduce noise\nMean of touching neighbors", "code": "local_mean_neighbor_count = cle.mean_of_touching_neighbors(neighbor_count, touch_matrix)\n\nparametric_image = cle.replace_intensities(tissue, local_mean_neighbor_count)\ncle.imshow(parametric_image, min_display_intensity=0, max_display_intensity=10, color_map='jet')"}
{"imports": "import pyclesperanto_prototype as cle\n\ncle.select_device('RTX')\n\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom skimage.io import imshow, imread\n\n# Laod example data\ninput_image = imread(\"../../data/Haase_MRT_tfl3d1.tif\")\ninput_image.shape\n\ncle.imshow(input_image)", "text": "\n\n## Rotation\nFor rotating an image, you need to provide angles corresponding to axes.", "code": "rotated = cle.rotate(input_image, angle_around_z_in_degrees=45)\ncle.imshow(rotated)"}
{"imports": "import pyclesperanto_prototype as cle\n\ncle.select_device('RTX')\n\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom skimage.io import imshow, imread\n\n# Laod example data\ninput_image = imread(\"../../data/Haase_MRT_tfl3d1.tif\")\ninput_image.shape\n\ncle.imshow(input_image)", "text": "\n\nImages are rotated around their center by default. You can change this by providing an additional parameter. The image will then be rotated around the origin.", "code": "rotated = cle.rotate(input_image, angle_around_z_in_degrees=15, rotate_around_center=False)\ncle.imshow(rotated)"}
{"imports": "import pyclesperanto_prototype as cle\n\ncle.select_device('RTX')\n\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom skimage.io import imshow, imread\n\n# Laod example data\ninput_image = imread(\"../../data/Haase_MRT_tfl3d1.tif\")\ninput_image.shape\n\ncle.imshow(input_image)", "text": "\n\n## Translation\nImages can be translate by providing translation distances along axes:", "code": "translated = cle.translate(input_image, translate_x=50, translate_y=-50)\ncle.imshow(translated)"}
{"imports": "import pyclesperanto_prototype as cle\n\ncle.select_device('RTX')\n\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom skimage.io import imshow, imread\n\n# Laod example data\ninput_image = imread(\"../../data/Haase_MRT_tfl3d1.tif\")\ninput_image.shape\n\ncle.imshow(input_image)", "text": "\n\n## Scaling\nYou can scale the image by providing scaling factors.", "code": "scaled = cle.scale(input_image, factor_x=0.5, factor_y=2)\ncle.imshow(scaled)"}
{"imports": "import pyclesperanto_prototype as cle\n\ncle.select_device('RTX')\n\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom skimage.io import imshow, imread\n\n# Laod example data\ninput_image = imread(\"../../data/Haase_MRT_tfl3d1.tif\")\ninput_image.shape\n\ncle.imshow(input_image)", "text": "\n\n## Auto-size\nEspecially for scaling, the `auto_size` parameter may be helpful:", "code": "scaled = cle.scale(input_image, factor_x=0.5, factor_y=2, auto_size=True)\ncle.imshow(scaled)"}
{"imports": "import pyclesperanto_prototype as cle\n\ncle.select_device('RTX')\n\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom skimage.io import imshow, imread\n\n# Laod example data\ninput_image = imread(\"../../data/Haase_MRT_tfl3d1.tif\")\ninput_image.shape\n\ncle.imshow(input_image)", "text": "\n\n## Rigid transform\nRigid transforms allow to do translations and rotations in one shot", "code": "rigid_transformed = cle.rigid_transform(input_image, translate_x=20, angle_around_z_in_degrees=45)\ncle.imshow(rigid_transformed)"}
{"imports": "from skimage.io import imread\nimport matplotlib.pyplot as plt\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n## Deskewing with linear interpolation", "code": "deskewed = cle.deskew_y(original_image, \n                        angle_in_degrees=deskewing_angle_in_degrees, \n                        voxel_size_x=voxel_size_x_in_microns, \n                        voxel_size_y=voxel_size_y_in_microns, \n                        voxel_size_z=voxel_size_z_in_microns,\n                       linear_interpolation=True)\n\ndeskewed.shape\n\ncle.imshow(deskewed[:,:250,100])"}
{"imports": "from skimage.io import imread\nimport matplotlib.pyplot as plt\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")", "text": "\n\n## Deskewing without linear interpolation", "code": "deskewed_wo_interpolation = cle.deskew_y(original_image, \n                        angle_in_degrees=deskewing_angle_in_degrees, \n                        voxel_size_x=voxel_size_x_in_microns, \n                        voxel_size_y=voxel_size_y_in_microns, \n                        voxel_size_z=voxel_size_z_in_microns,\n                        linear_interpolation=False)\n\ndeskewed_wo_interpolation.shape\n\ncle.imshow(deskewed_wo_interpolation[:,:250,100])"}
{"imports": "from skimage.io import imread\nimport matplotlib.pyplot as plt\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")\n\ncle.__version__", "text": "\n\n## Deskewing with orthogonal interpolation", "code": "deskewed = cle.deskew_y(original_image, \n                        angle_in_degrees=deskewing_angle_in_degrees, \n                        voxel_size_x=voxel_size_x_in_microns, \n                        voxel_size_y=voxel_size_y_in_microns, \n                        voxel_size_z=voxel_size_z_in_microns,\n                        linear_interpolation=True)\n\ndeskewed.shape\n\ncle.imshow(deskewed[:,:250,100])"}
{"imports": "from skimage.io import imread\nimport matplotlib.pyplot as plt\nimport pyclesperanto_prototype as cle\n\ncle.select_device(\"RTX\")\n\ncle.__version__", "text": "\n\n## Deskewing without orthogonal interpolation", "code": "deskewed_wo_interpolation = cle.deskew_y(original_image, \n                        angle_in_degrees=deskewing_angle_in_degrees, \n                        voxel_size_x=voxel_size_x_in_microns, \n                        voxel_size_y=voxel_size_y_in_microns, \n                        voxel_size_z=voxel_size_z_in_microns,\n                        linear_interpolation=False)\n\ndeskewed_wo_interpolation.shape\n\ncle.imshow(deskewed_wo_interpolation[:,:250,100])"}
{"imports": "import numpy as np\nimport pyclesperanto_prototype as cle", "text": "\n\n## Deskew it", "code": "deskewed = cle.deskew_y(rbc, \n                        angle_in_degrees=deskewing_angle_in_degrees, \n                        voxel_size_x=voxel_size_x_in_microns, \n                        voxel_size_y=voxel_size_y_in_microns, \n                        voxel_size_z=voxel_size_z_in_microns)\n\ndeskewed.shape"}
